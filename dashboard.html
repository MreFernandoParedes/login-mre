<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sistema IA â€” PaÃ­ses interactivos</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #001a33;
    }
    #globe {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="globe"></div>

  <!-- Import Map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <!-- CÃ³digo principal -->
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    console.log("ðŸŒŽ Iniciando globo interactivo...");

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById("globe").appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(5, 3, 5);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x404040, 1.5));

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ðŸŒ Textura base
    const textureLoader = new THREE.TextureLoader();
    const earthTexture = textureLoader.load("https://cdn.jsdelivr.net/gh/turban/webgl-earth@master/images/2_no_clouds_4k.jpg");

    const earth = new THREE.Mesh(
      new THREE.SphereGeometry(1, 64, 64),
      new THREE.MeshPhongMaterial({ map: earthTexture })
    );
    scene.add(earth);

    // ðŸŽ¯ Raycaster y mouse
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let selectedCountry = null;

    // ðŸ”¹ Cargar paÃ­ses (GeoJSON)
    fetch("https://cdn.jsdelivr.net/gh/johan/world.geo.json/world.geo.json")
      .then(res => res.json())
      .then(data => {
        data.features.forEach((feature, i) => {
          const color = new THREE.Color(0x0088ff);
          const countryMesh = drawCountry(feature, color);
          countryMesh.userData = { name: feature.properties.name };
          scene.add(countryMesh);
        });
      });

    function drawCountry(feature, color) {
      const coords = feature.geometry.coordinates;
      const type = feature.geometry.type;
      const group = new THREE.Group();

      if (type === "Polygon") group.add(drawPolygon(coords, color));
      else if (type === "MultiPolygon") coords.forEach(p => group.add(drawPolygon(p, color)));

      return group;
    }

    function drawPolygon(polygon, color) {
      const shape = new THREE.Shape();

      polygon[0].forEach(([lon, lat], idx) => {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const radius = 1.001;

        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.cos(phi);
        const z = radius * Math.sin(phi) * Math.sin(theta);

        if (idx === 0) shape.moveTo(x, z);
        else shape.lineTo(x, z);
      });

      const geometry = new THREE.ShapeGeometry(shape);
      const material = new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0.35,
        side: THREE.DoubleSide
      });

      const mesh = new THREE.Mesh(geometry, material);
      mesh.rotation.y = Math.PI;
      mesh.rotation.x = Math.PI / 2;
      return mesh;
    }

    // ðŸ–±ï¸ Detectar clics
    window.addEventListener("click", (event) => {
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);

      if (intersects.length > 0) {
        const obj = intersects[0].object;
        const countryName = obj.parent?.userData?.name || obj.userData?.name;

        if (countryName) {
          console.log("ðŸŒ PaÃ­s seleccionado:", countryName);

          // Restaurar color anterior
          if (selectedCountry) {
            selectedCountry.material.color.set(0x0088ff);
          }

          // Nuevo paÃ­s
          selectedCountry = obj;
          selectedCountry.material.color.set(0xffff00);

          // Abrir nueva pÃ¡gina (paÃ­s.html)
          const encoded = encodeURIComponent(countryName);
          window.location.href = `pais.html?nombre=${encoded}`;
        }
      }
    });

    // ðŸŽ¥ AnimaciÃ³n
    function animate() {
      requestAnimationFrame(animate);
      earth.rotation.y += 0.0008;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
